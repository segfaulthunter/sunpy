# -*- coding: utf-8 -*-
# Author: Florian Mayer <florian.mayer@bitsrc.org>

from itertools import izip

import numpy as np
import scipy.ndimage

__all__ = ["bpmap", "vis_clean"]

# NOTE: TBD. Now uniform weighting, normalized for IDL compatibility.
weights = np.array([1] * 30, dtype=np.double) / 30.

def _center(arr):
    """
     For arrays of odd length, return middle element. For arrays of even
     length, return mean of the two centroid elements.
    """
    d, m = divmod(len(arr), 2)
    if m == 0:
        return (arr[d - 1] + arr[d]) / 2.
    return arr[d]


# NOTE: The IDL implementation memoizes the result. Why?
def _vis_bpmap_get_xypi(npx, pixel):
    """
    Create coordinate mesh for use by bpmap. Return tuple of array of
    x coordinates and array of y coordinates.
    """
    # Coordinates per dimension with the center of the image at (0, 0).
    # This assumes a square image.
    coords = np.arange(0, npx) - (npx - 1) / 2.
    xs, ys = np.meshgrid(coords, coords)
    return xs * (-2 * np.pi * pixel), ys * (-2 * np.pi * pixel)


def _center_vis(visin):
    """
    Return visibilities for a point in the center of the image.
    """
    # Apparently, this is all the vis_map2vis call of vis_psf in the original
    # IDL code does, so we needn't implement all this here because the special
    # case of the source in the middle of an image with an odd number of pixels
    # always ends up outputting all 1+0j. We still need the visin to know how
    # many visibilites we need.

    vis = visin.copy()
    vis["obsvis"][:] = np.ones((30,), dtype=np.complex)
    return vis
    # phase = 2 * np.pi * vis['u'] + 2 * np.pi * vis['v']
    # return np.cos(phase) + 1j * np.sin(phase)


def _vis_psf_center(visin, pixel, dims):
    """
    Return back projected map from the visibilities resulting from
    a single point source in the middle of the image.

    The PSF of the detector.
    """
    # XXX: Why 1.6?
    npx = int(np.max(dims) * 1.6)
    npx += 1 - npx % 2
    return bpmap(_center_vis(visin), npx, pixel)


def _vis_psf(visin, psf_center, max_, pixel, dims):
    """
     Return PSF for detector at max_.
    """
    # mp is backprojected map from visibilities generated by
    # point in center

    # XXX: Why 1.6?
    npx = int(np.max(dims) * 1.6)
    npx += 1 - npx % 2

    fov_shift = (npx - np.max(dims)) / 2
    cpsf = dims / 2 # Center
    id, jd = max_ - cpsf

    return np.roll(
        np.roll(psf_center, id, axis=0),
        jd, axis=1
    )[fov_shift:fov_shift+dims[0], fov_shift:fov_shift+dims[0]]


def vis_clean(visin, iterations, npx, pixel, weights=weights, clean_box=None,
              negativemax=True, gain=0.05, std_dev=4):
    # FIXME: clean_box is not None
    if npx % 2 == 0:
        # NOTE: Maybe force odd like in IDL? Probably not a good idea though.
        # That'd be npx += npx % 2
        raise ValueError("Odd npx required.")

    dmap = bpmap(visin, npx, pixel, weights)

    clean_map = np.zeros(dmap.shape)

    psf_center = _vis_psf_center(visin, pixel, np.array([npx, npx]))
    psf_center /= psf_center.max()

    if clean_box is None:
        # NOTE: Copy?
        cmap = dmap
    else:
        cmap = dmap[clean_box]

    for _ in xrange(iterations):
        if negativemax:
            amax = np.abs(cmap).argmax()
        else:
            amax = cmap.argmax()

        # Coordinates of maximum
        i, j = np.unravel_index(amax, cmap.shape)

        zflux = cmap[i, j]
        if negativemax and zflux < 0:
            break

        psf = _vis_psf(
            visin, psf_center, np.array([i, j]), pixel, np.array([npx, npx])
        )
        flux = zflux * gain / psf.max()

        cmap -= psf * flux
        clean_map[i, j] += flux

    kernel = np.zeros((npx, npx))
    # Image forced to odd length, so this is possible.
    kernel[npx / 2, npx / 2] = 1.
    # TODO: Find out if there is a more elegant way. The advantage of this is
    # that it is trivially what we want.
    kernel = scipy.ndimage.filters.gaussian_filter(
        kernel, std_dev, mode="constant", cval=0
    )

    # FIXME: std_dev needs to be made scale invariant.
    clean_map = scipy.ndimage.filters.gaussian_filter(
       clean_map, std_dev, mode="constant", cval=0
    ) / pixel**2

    # Scale cmap to same scale as clean_map by using the center value of the
    # Gaussian filter kernel.
    resid_map = cmap * kernel.max() / pixel ** 2
    clean_image=clean_map + scipy.ndimage.filters.gaussian_filter(
       resid_map, std_dev, mode="constant", cval=0
    )
    return clean_image


# FIXME: Let user supply FOV, or do that elsewhere?
def bpmap(visin, npx, pixel, weights=weights):
    """
     Back-project map from visibilities.
    """
    # Every visibility must have a weight.
    assert len(visin) == len(weights)

    xypi = _vis_bpmap_get_xypi(npx, pixel)
    map = np.zeros((npx, npx))
    for sfw, vis in izip(weights, visin):
        uv = xypi[0] * vis["u"] + xypi[1] * vis["v"]
        map += sfw * np.real(vis["obsvis"] * (np.cos(uv) + 1j * np.sin(uv)))
    return map


def bpmap_vec(visin, npx, pixel, weights=weights):
    """
     Vectorized version of bpmap. Compare bpmap.
    """
    # NOTE: This seems a bit slower than the explicit loop. Why?
    # Maybe the loop overhead for 30 visibilities is negligible
    # compared to the overhead of doing and keeping the sum for all elements
    # and only then doing the product
    assert len(visin) == len(weights)
    xpi, ypi = _vis_bpmap_get_xypi(npx, pixel)
    phase = visin["u"][:, np.newaxis, np.newaxis] * xpi[np.newaxis]
    phase += visin["v"][:, np.newaxis, np.newaxis] * ypi[np.newaxis]
    return np.real(np.tensordot(
        weights * visin["obsvis"],
        # Apparently cheaper than using np.exp.
        np.cos(phase) + 1j * np.sin(phase),
        axes=[[0], [0]]
    ))
    # Easier approach, probably worse in memory-usage:
    # return np.real(np.sum(
    #    (weights * visin["obsvis"])[:, np.newaxis, np.newaxis] *
    #    np.exp(1j * phase),
    #    axis=0
    # ))


if __name__ == "__main__":
    # This just spawns a load of plots.
    
    from astropy.io import fits as pyfits
    from matplotlib import pyplot as plt

    # For 2.6 compatibility.
    from contextlib import nested

    import timeit

    with nested(
            pyfits.open(r"C:\users\florian\vis.fits"),
            pyfits.open(r"C:\users\florian\vis7.fits"),
            pyfits.open(r"C:\users\florian\map2.fits"),
            pyfits.open(r"C:\users\florian\cleanim4.fits"),
            pyfits.open(r"C:\users\florian\psf007.fits"),
            pyfits.open(r"C:\users\florian\gauss.fits"),
            pyfits.open(r"C:\users\florian\gaussm.fits"),
    ) as (fd, fd3, fd2, fd4, fd5, fdg, fdgm):
        a_vis = fd[1].data
        c_vis = fd3[1].data
        b = fd2[0].data
        clean_idl = fd4[0].data

        psf00 = fd5[0].data
        vgauss = fdg[1].data
        mgauss = fdgm[0].data
        b = mgauss

# Verdict of the following: bpmap_vec is a bit slower.
#     print "Vect", timeit.timeit("bpmap_vec(fd[1].data, 200, 80 / 200.)",
#                          setup=r"""from __main__ import bpmap_vec;
# from astropy.io import fits as pyfits;
# fd = pyfits.open(r"C:\users\florian\vis2.fits")""",
#                          number=50)

#     print "Loop", timeit.timeit("bpmap(fd[1].data, 200, 80 / 200.)",
#                          setup=r"""from __main__ import bpmap_vec, bpmap;
# from astropy.io import fits as pyfits;
# fd = pyfits.open(r"C:\users\florian\vis2.fits")""",
#                          number=50)

    # FIXME: a_vis
    a = bpmap_vec(vgauss, 200, 80 / 200.)

    c = vis_clean(c_vis, 100, 65, 1.)

    c1 = bpmap_vec(c_vis, 65, 80 / 65.)

    plt.figure()
    plt.imshow(a, interpolation="nearest")
    plt.title("Backproject Python")
    plt.colorbar()

    plt.figure()
    plt.imshow(b, interpolation="nearest")
    plt.title("Backproject IDL")
    plt.colorbar()

    plt.figure()
    plt.imshow(a - b, interpolation="nearest")
    plt.title("Backproject Diff")
    plt.colorbar()

    plt.figure()
    plt.imshow(c, interpolation="nearest")
    plt.title("CLEAN")
    plt.colorbar()

    plt.figure()
    plt.imshow(clean_idl, interpolation="nearest")
    plt.title("CLEAN IDL")
    plt.colorbar()

    plt.figure()
    plt.imshow(c - clean_idl, interpolation="nearest")
    plt.title("CLEAN Diff")
    plt.colorbar()

    plt.figure()
    plt.imshow(c1, interpolation="nearest")
    plt.title("Backproject")
    plt.colorbar()

    psf = _vis_psf(
        c_vis,
        _vis_psf_center(c_vis, 1., np.array([105, 105])),
        np.array([52, 52]), 1., np.array([105, 105])
    )
    plt.figure()
    plt.imshow(psf, interpolation="nearest")
    plt.title("PSF")
    plt.colorbar()

    plt.figure()
    plt.imshow(psf00, interpolation="nearest")
    plt.title("PSF IDL")
    plt.colorbar()

    plt.figure()
    plt.imshow(psf - psf00, interpolation="nearest")
    plt.title("PSF Diff")
    plt.colorbar()

    plt.show()
